name: Build, Release, and Update Beta Info

on:
  push:
    branches: [main, master]
    tags: ['v*']
  workflow_dispatch:
    inputs:
      forceRelease:
        description: 'Force release creation'
        required: false
        type: boolean
        default: false

permissions:
  contents: write

jobs:
  release:
    runs-on: windows-latest  # Changed to Windows for native module compatibility

    steps:
      - name: Check out Git repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0  # Fetch all history for version determination

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: 18  # Updated to Node.js 18 LTS
          cache: 'npm'  # Enable caching

      - name: Install bun
        uses: oven-sh/setup-bun@v1
        with:
          bun-version: latest

      - name: Get version information
        id: get_version
        shell: bash
        run: |
          # Check if this is a tag push
          if [[ $GITHUB_REF == refs/tags/v* ]]; then
            # For tags, use the tag name
            VERSION=${GITHUB_REF#refs/tags/}
            echo "VERSION=$VERSION" >> $GITHUB_OUTPUT
            echo "IS_TAG=true" >> $GITHUB_OUTPUT
          else
            # For regular commits, use package.json version + beta + short SHA
            PKG_VERSION=$(node -p "require('./package.json').version")
            SHORT_SHA=$(git rev-parse --short HEAD)
            VERSION="v${PKG_VERSION}-beta.${SHORT_SHA}"
            echo "VERSION=$VERSION" >> $GITHUB_OUTPUT
            echo "IS_TAG=false" >> $GITHUB_OUTPUT
          fi
          
          # Check if this is a beta release
          if echo "$VERSION" | grep -E "beta|alpha|rc" > /dev/null; then
            echo "IS_BETA=true" >> $GITHUB_OUTPUT
          else
            echo "IS_BETA=false" >> $GITHUB_OUTPUT
          fi

      - name: Install dependencies
        run: npm ci  # Using npm ci for more reliable installations

      - name: Setup Visual Studio Build Tools
        run: |
          # Use native Windows environment 
          echo "Setting up build environment for native modules..."
          npm config set msvs_version 2019

      - name: Build Electron app
        run: npm run build
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          ELECTRON_CACHE: ${{ github.workspace }}/.cache/electron
          ELECTRON_BUILDER_CACHE: ${{ github.workspace }}/.cache/electron-builder
          
      - name: Scan with VirusTotal
        id: virustotal
        shell: bash
        run: |
          echo "Scanning executables with VirusTotal..."
          VT_RESULTS=""
          
          # Check if API key exists
          if [ -z "${{ secrets.VT_API_KEY }}" ]; then
            echo "::warning::VirusTotal API key not found. Skipping virus scan."
            VT_RESULTS="âš ï¸ VirusTotal scan was skipped due to missing API key. Please add VT_API_KEY to repository secrets."
          else
            for file in dist/*.exe; do
              if [ -f "$file" ]; then
                echo "Scanning $file..."
                FILE_NAME=$(basename "$file")
                
                # Generate hash for manual lookup on VirusTotal
                FILE_HASH=$(certutil -hashfile "$file" SHA256 | grep -v "hash" | tr -d " \t\n\r")
                echo "File hash: $FILE_HASH"
                
                # Check file size before attempting to upload (limit is ~32MB for VirusTotal API)
                FILE_SIZE_BYTES=$(stat -c%s "$file" 2>/dev/null || stat -f%z "$file")
                FILE_SIZE_MB=$(echo "scale=2; $FILE_SIZE_BYTES / 1048576" | bc)
                echo "File size: $FILE_SIZE_MB MB"
                
                # Store hash regardless of file size
                if [ "${{ steps.get_version.outputs.IS_BETA }}" = "true" ]; then
                  echo "sha256=$FILE_HASH" >> $GITHUB_OUTPUT
                fi
                
                # Skip files larger than 32MB
                if (( $(echo "$FILE_SIZE_MB > 32" | bc -l) )); then
                  echo "File too large for VirusTotal API (> 32MB), adding manual lookup link"
                  MANUAL_LINK="https://www.virustotal.com/gui/file/$FILE_HASH/detection"
                  VT_RESULTS="$VT_RESULTS\n- $FILE_NAME: âš ï¸ File too large for API upload ($FILE_SIZE_MB MB). [Check manually]($MANUAL_LINK) using hash: \`$FILE_HASH\`"
                  continue
                fi
                
                # Try to get existing analysis first
                echo "Checking if file was previously analyzed..."
                EXISTING=$(curl --silent --request GET \
                  --url "https://www.virustotal.com/api/v3/files/$FILE_HASH" \
                  --header "x-apikey: ${{ secrets.VT_API_KEY }}")
                
                # Check if we got a valid response with results
                if echo "$EXISTING" | jq -e '.data.attributes.last_analysis_results' >/dev/null 2>&1; then
                  echo "Existing analysis found, using those results"
                  MALICIOUS=$(echo "$EXISTING" | jq -r '.data.attributes.last_analysis_stats.malicious')
                  SUSPICIOUS=$(echo "$EXISTING" | jq -r '.data.attributes.last_analysis_stats.suspicious')
                  VT_LINK="https://www.virustotal.com/gui/file/$FILE_HASH"
                  VT_RESULTS="$VT_RESULTS\n- $FILE_NAME: $MALICIOUS malicious, $SUSPICIOUS suspicious - [View Report]($VT_LINK)"
                  continue
                fi
                
                # Upload file to VirusTotal
                echo "Uploading file to VirusTotal for analysis..."
                RESPONSE=$(curl --silent --request POST \
                  --url https://www.virustotal.com/api/v3/files \
                  --header "x-apikey: ${{ secrets.VT_API_KEY }}" \
                  --form "file=@$file")
                
                # Extract analysis ID
                if ! ANALYSIS_ID=$(echo "$RESPONSE" | jq -r '.data.id' 2>/dev/null); then
                  echo "Could not extract analysis ID from response"
                  echo "Response: $RESPONSE"
                  VT_RESULTS="$VT_RESULTS\n- $FILE_NAME: Failed to get analysis ID"
                  continue
                fi
                
                echo "Analysis ID: $ANALYSIS_ID"
                
                # Wait for analysis to complete (with timeout)
                ATTEMPTS=0
                MAX_ATTEMPTS=20
                STATUS="pending"
                
                while [ $ATTEMPTS -lt $MAX_ATTEMPTS ] && [ "$STATUS" != "completed" ]; do
                  sleep 15
                  ANALYSIS_RESPONSE=$(curl --silent --request GET \
                    --url "https://www.virustotal.com/api/v3/analyses/$ANALYSIS_ID" \
                    --header "x-apikey: ${{ secrets.VT_API_KEY }}")
                  
                  STATUS=$(echo "$ANALYSIS_RESPONSE" | jq -r '.data.attributes.status' 2>/dev/null)
                  ATTEMPTS=$((ATTEMPTS+1))
                  echo "Waiting for analysis to complete... Attempt $ATTEMPTS/$MAX_ATTEMPTS (Status: $STATUS)"
                done
                
                if [ "$STATUS" = "completed" ]; then
                  # Extract results
                  if MALICIOUS=$(echo "$ANALYSIS_RESPONSE" | jq -r '.data.attributes.stats.malicious' 2>/dev/null) && \
                     SUSPICIOUS=$(echo "$ANALYSIS_RESPONSE" | jq -r '.data.attributes.stats.suspicious' 2>/dev/null) && \
                     RESOURCE_ID=$(echo "$ANALYSIS_RESPONSE" | jq -r '.meta.file_info.sha256' 2>/dev/null); then
                    
                    VT_LINK="https://www.virustotal.com/gui/file/$RESOURCE_ID"
                    VT_RESULTS="$VT_RESULTS\n- $FILE_NAME: $MALICIOUS malicious, $SUSPICIOUS suspicious - [View Report]($VT_LINK)"
                  else
                    VT_RESULTS="$VT_RESULTS\n- $FILE_NAME: Analysis completed but unable to extract results"
                  fi
                else
                  VT_RESULTS="$VT_RESULTS\n- $FILE_NAME: Analysis timed out or failed"
                fi
              fi
            done
          fi
          
          echo "virustotal_results<<EOF" >> $GITHUB_ENV
          echo -e "$VT_RESULTS" >> $GITHUB_ENV
          echo "EOF" >> $GITHUB_ENV

      - name: Create Release
        id: create_release
        uses: softprops/action-gh-release@v1
        if: ${{ startsWith(github.ref, 'refs/tags/') || steps.get_version.outputs.IS_BETA == 'true' || github.event.inputs.forceRelease == 'true' }}
        with:
          tag_name: ${{ steps.get_version.outputs.VERSION }}
          name: ${{ steps.get_version.outputs.IS_BETA == 'true' && 'Beta Release ' || 'Release ' }}${{ steps.get_version.outputs.VERSION }}
          prerelease: ${{ steps.get_version.outputs.IS_BETA == 'true' || steps.get_version.outputs.IS_TAG == 'false' }}
          body: |
            ${{ steps.get_version.outputs.IS_BETA == 'true' && '## âš ï¸ Beta Release' || (steps.get_version.outputs.IS_TAG == 'false' && '## Automated Build' || '## Stable Release') }}
            
            ${{ steps.get_version.outputs.IS_BETA == 'true' && 'This is a beta release and may contain bugs. Use at your own risk.' || (steps.get_version.outputs.IS_TAG == 'false' && 'This is an automated build from the latest commit.' || 'This is a stable release of AlrightLauncher.') }}
            
            ## Changes
            ${{ github.event.head_commit.message || 'No description provided' }}
            
            ## VirusTotal Scan Results
            ${{ env.virustotal_results }}
            
            ## Release Files
            - ðŸ’» Windows Installer: Includes everything you need to run the launcher
            - ðŸ“ Latest.yml: Automatic update information file
          files: |
            dist/*.exe
            dist/latest.yml
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      # Update updates.json for beta releases
      - name: Update Beta Info in updates.json
        if: steps.get_version.outputs.IS_BETA == 'true'
        shell: bash
        run: |
          # Get release info from the created release
          VERSION="${{ steps.get_version.outputs.VERSION }}"
          VERSION=${VERSION#v}  # Remove 'v' prefix if present
          RELEASE_DATE=$(date -u +"%Y-%m-%d")
          RELEASE_NOTES="${{ steps.create_release.outputs.body || github.event.release.body }}"
          SHA256="${{ steps.virustotal.outputs.sha256 }}"
          
          # Check if updates.json exists, create a default one if not
          if [ ! -f "updates.json" ]; then
            echo "Creating default updates.json file"
            echo '{
              "stable": {
                "version": "3.0.0",
                "releaseDate": "2023-01-01",
                "downloadUrl": "",
                "sha256": "",
                "releaseNotes": "Initial release"
              },
              "beta": {
                "version": "3.0.0",
                "releaseDate": "2023-01-01",
                "downloadUrl": "",
                "sha256": "",
                "releaseNotes": "Initial beta release"
              }
            }' > updates.json
          fi
          
          # Find the installer filename from dist directory
          for file in dist/*.exe; do
            if [ -f "$file" ]; then
              FILENAME=$(basename "$file")
              break
            fi
          done
          
          # Create the proper GitHub release asset download URL
          DOWNLOAD_URL="https://github.com/${{ github.repository }}/releases/download/${{ steps.get_version.outputs.VERSION }}/${FILENAME}"
          
          echo "Using download URL: $DOWNLOAD_URL"
          
          # Escape newlines in release notes
          RELEASE_NOTES=$(echo "$RELEASE_NOTES" | jq -sR .)
          
          # Update the updates.json file
          jq ".beta.version = \"$VERSION\" | 
              .beta.releaseDate = \"$RELEASE_DATE\" | 
              .beta.downloadUrl = \"$DOWNLOAD_URL\" | 
              .beta.sha256 = \"$SHA256\" | 
              .beta.releaseNotes = $RELEASE_NOTES" updates.json > updates.json.new || {
            echo "jq command failed, trying alternative approach"
            cp updates.json updates.json.bak
            # Create updated file using Python as fallback
            python -c "import json, os
            data = json.load(open('updates.json'))
            data['beta']['version'] = '$VERSION'
            data['beta']['releaseDate'] = '$RELEASE_DATE'
            data['beta']['downloadUrl'] = '$DOWNLOAD_URL'
            data['beta']['sha256'] = '$SHA256'
            data['beta']['releaseNotes'] = '''$RELEASE_NOTES'''
            json.dump(data, open('updates.json.new', 'w'), indent=2)"
          }
          
          if [ -f "updates.json.new" ]; then
            mv updates.json.new updates.json
          else
            echo "Failed to create updated updates.json file"
            exit 1
          fi
          
          git config --local user.email "action@github.com"
          git config --local user.name "GitHub Action"
          git add updates.json
          git commit -m "Update beta release info to ${{ steps.get_version.outputs.VERSION }}"
          git push